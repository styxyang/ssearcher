#include "gtest/gtest.h"

extern "C" {
#include "ss_config.h"
#include "ss_trie.h"
#include "ss_magic.h"
}

using namespace std;

class TrieTest : public ::testing::Test
{
  protected:
    struct trie *tr;

    TrieTest(): tr(NULL) {}

    virtual void SetUp()
    {
        trie_init(&tr);
    }

    virtual void TearDown()
    {
        trie_destroy(tr);
    }
};

TEST_F(TrieTest, InsertOneElement)
{
    srand(time(NULL));
    int cnt = rand() % 20 + 1;
    uint32_t *array = (uint32_t *)malloc(sizeof(uint32_t) * cnt);

    int i;
    for (i = 0; i < cnt; i++) {
        array[i] = rand() % 256;
    }
    EXPECT_NE(trie_insert(tr, array, cnt), (void *)NULL);  // make sure the entry is inserted
    EXPECT_EQ(trie_insert(tr, array, cnt), (void *)NULL);  // can't insert same entry twice

    EXPECT_NE(trie_lookup(tr, array, cnt), (void *)NULL);  /* make sure it can be found */

    array[cnt-1] += 2;
    EXPECT_EQ(trie_lookup(tr, array, cnt), (void *)NULL);  /* can't found a modified entry */

    free(array);
}

TEST_F(TrieTest, SearchInMany)
{
    srand(time(NULL));
    const int nentries = 20;
    uint32_t *array[nentries];
    int cnts[nentries];

    int i, j;
    // insert entries into trie
    for (i = 0; i < nentries; i++) {
        int cnt = rand() % 20 + 1;  // random size of an entry
        array[i] = (uint32_t *)malloc(sizeof(uint32_t) * cnt);
        cnts[i] = cnt;
        for (j = 0; j < cnt; j++) {
            array[i][j] = rand() % 16;
        }
        EXPECT_NE(trie_insert(tr, array[i], cnt), (void *)NULL);
    }

    // query entries
    for (i = 0; i < nentries; i++) {
        EXPECT_NE(trie_lookup(tr, array[i], cnts[i]), (void *)NULL);
        free(array[i]);
    }
}

TEST_F(TrieTest, SearchMagic)
{
    int i;
    static uint32_t magic_index[][MENTRY_LEN + 1] = {
        {0x000, 0x000, 0x000, 0x014, 0x066, 0x074, 0x079, 0x070, 8}, 
        {0x000, 0x000, 0x000, 0x018, 0x066, 0x074, 0x079, 0x070, 8}, 
        {0x000, 0x000, 0x000, 0x020, 0x066, 0x074, 0x079, 0x070, 8}, 
        {0x000, 0x000, 0x001, 0x000, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x01F, 0x09D, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 2}, 
        {0x01F, 0x0A0, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 2}, 
        {0x025, 0x050, 0x044, 0x046, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x038, 0x042, 0x050, 0x053, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x042, 0x04D, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 2}, 
        {0x043, 0x044, 0x030, 0x030, 0x031, 0x100, 0x100, 0x100, 5}, 
        {0x047, 0x049, 0x046, 0x038, 0x037, 0x061, 0x100, 0x100, 6}, 
        {0x047, 0x049, 0x046, 0x038, 0x039, 0x061, 0x100, 0x100, 6}, 
        {0x049, 0x044, 0x033, 0x100, 0x100, 0x100, 0x100, 0x100, 3}, 
        {0x049, 0x049, 0x02A, 0x000, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x04D, 0x04D, 0x000, 0x02A, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x04D, 0x05A, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 2}, 
        {0x04F, 0x067, 0x067, 0x053, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x050, 0x04B, 0x003, 0x004, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x050, 0x04B, 0x005, 0x006, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x050, 0x04B, 0x007, 0x008, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x052, 0x061, 0x072, 0x021, 0x01A, 0x007, 0x000, 0x100, 7}, 
        {0x052, 0x061, 0x072, 0x021, 0x01A, 0x007, 0x001, 0x000, 8}, 
        {0x066, 0x04C, 0x061, 0x043, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x07F, 0x045, 0x04C, 0x046, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x089, 0x050, 0x04E, 0x047, 0x00D, 0x00A, 0x01A, 0x00A, 8}, 
        {0x0CA, 0x0FE, 0x0BA, 0x0BE, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x0CE, 0x0FA, 0x0ED, 0x0FE, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x0CF, 0x0FA, 0x0ED, 0x0FE, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x0D0, 0x0CF, 0x011, 0x0E0, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x0EF, 0x0BB, 0x0BF, 0x100, 0x100, 0x100, 0x100, 0x100, 3}, 
        {0x0FE, 0x0ED, 0x0FA, 0x0CE, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x0FE, 0x0ED, 0x0FA, 0x0CF, 0x100, 0x100, 0x100, 0x100, 4}, 
        {0x0FF, 0x0FB, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 2}, 
        {0x0FF, 0x0FE, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 2}, 
        {0x0FF, 0x0FE, 0x000, 0x000, 0x100, 0x100, 0x100, 0x100, 4}
    };

    for (i = 0; i < sizeof(magic_index) / (MENTRY_LEN + 1) / sizeof(uint32_t); i++) {
        EXPECT_NE(trie_insert(tr, &magic_index[i][0], magic_index[i][8]), (void *)NULL);
    }
    uint32_t array0[] = {0x052, 0x061, 0x072, 0x021, 0x01A, 0x007, 0x001, 0x000};
    EXPECT_NE(trie_lookup(tr, array0, 8), (void *)NULL);
    uint32_t array1[] = {0x052, 0x061, 0x072, 0x021, 0x01A, 0x007, 0x001, 0x010};
    EXPECT_EQ(trie_lookup(tr, array1, 8), (void *)NULL);
    uint32_t array2[] = {0x052, 0x060, 0x072, 0x021, 0x01A, 0x007, 0x001, 0x000};
    EXPECT_EQ(trie_lookup(tr, array2, 8), (void *)NULL);
    uint32_t array3[] = {0x052, 0x061, 0x072, 0x021, 0x01A, 0x007, 0x001};
    EXPECT_EQ(trie_lookup(tr, array3, 7), (void *)NULL);
}
